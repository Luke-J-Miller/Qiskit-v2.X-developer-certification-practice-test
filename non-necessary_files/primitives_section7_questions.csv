Question,Answer Choice 1,Answer Choice 2,Answer Choice 3,Answer Choice 4,Correct Answer Choice,Explanation
"In Primitives V2, what does a PUB (Primitive Unified Bloc) minimally contain for the Estimator?",A list of circuits and one observable per circuit,"A single circuit, observables array, and parameter value sets",Only observables and precision; circuits are inferred,A single observable and shots,"A single circuit, observables array, and parameter value sets",Each Estimator V2 PUB has one circuit and the data to broadcast to it (observables and parameter value sets).
Which statement best describes the Sampler V2’s output compared to Sampler V1?,Sampler V2 returns quasi-probabilities; V1 returns raw bitstrings,Both V1 and V2 return quasi-probabilities by default,Sampler V2 returns per‑shot bitstrings; V1 returns quasi‑probability distributions,Sampler V2 returns density matrices; V1 returns bitstrings,Sampler V2 returns per‑shot bitstrings; V1 returns quasi‑probability distributions,V2 emphasizes sampling outcomes (per‑shot bitstrings) while V1 exposed quasi‑probability estimates.
"In Primitives V2, where is the 'shots' argument specified for the Sampler?",As a global option set via set_options(),In the run() method and/or per‑PUB tuple,Only in the constructor of the Sampler,It no longer exists in V2,In the run() method and/or per‑PUB tuple,"V2 surfaces sampling overhead directly: run([...], shots=...) and a PUB may override it."
Which class is a V2 reference implementation of the Estimator that uses full statevector simulation?,BackendEstimatorV2,StatevectorEstimator,BaseEstimatorV2,EstimatorResult,StatevectorEstimator,The docs list StatevectorEstimator as the reference (statevector) implementation of BaseEstimatorV2.
Which V2 base class defines the latest Sampler abstraction?,BaseSamplerV1,BackendSamplerV2,BaseSamplerV2,StatevectorSampler,BaseSamplerV2,BaseSamplerV2 is the abstract V2 interface; others are implementations.
What object type does estimator.run(...) return before you call result()?,PrimitiveResult,PubResult,BasePrimitiveJob,SamplerResult,BasePrimitiveJob,run() returns a job object; result() yields the results per PUB.
"In V2 Estimator output, where are the expectation values stored for each PUB?",job.result().values,job.result()[i].data.evs,job.result().quasi_dists[i],job.result()[i].data.counts,job.result()[i].data.evs,Each PUB yields a PubResult whose data has evs (and stds).
"What do V2 result containers organize the Sampler data by, enabling compatibility with dynamic circuits?",Measurement levels,Classical register names defined in the circuit,Quantum register names only,Gate labels,Classical register names defined in the circuit,"Sampler V2 organizes data per classical output register name (e.g., 'meas', 'alpha')."
Which method helps convert per‑shot Sampler V2 output into a counts dictionary?,BitArray.to_quasi(),DataBin.as_counts(),BitArray.get_counts(),PrimitiveResult.counts(),BitArray.get_counts(),The docs show using result[i].data.<creg>.get_counts().
Which statement about broadcasting in Estimator V2 is correct?,Broadcasting is not supported; shapes must match exactly,Only 1D arrays are broadcast; 2D is disallowed,Numpy broadcasting applies across observables and parameter value sets,"Broadcasting applies only to observables, not parameters",Numpy broadcasting applies across observables and parameter value sets,The API uses standard NumPy broadcasting to combine observable arrays and parameter value arrays.
Which of the following is retained mainly for backward compatibility and not favored anymore?,BaseEstimatorV2 and BaseSamplerV2,BaseEstimatorV1 and BaseSamplerV1,StatevectorEstimator and StatevectorSampler,BackendEstimatorV2 and BackendSamplerV2,BaseEstimatorV1 and BaseSamplerV1,V1 interfaces are retained for backward compatibility; V2 is the modern interface.
"In the favored V2 pattern, how would you run one circuit with three parameter sets in the Sampler?","sampler.run([circuit]*3, [vals1, vals2, vals3])","sampler.run([(circuit, [vals1, vals2, vals3])])","sampler.run([(circuit, vals1), (circuit, vals2), (circuit, vals3)])","sampler.run([circuit], parameters=[vals1, vals2, vals3])","sampler.run([(circuit, [vals1, vals2, vals3])])",A single PUB with the circuit and an array of parameter value sets is the V2 pattern.
Which statement about EstimatorV2 precision is correct?,Precision is an option only; run() cannot set it,EstimatorV2 has no precision concept; use shots only,"You can pass precision to run(), and PUBs may also specify precision",Precision is a constructor‑only argument,"You can pass precision to run(), and PUBs may also specify precision",V2 surfaces a precision target; the run() method can accept it.
What is returned by BaseSamplerV2.run([...]).result()?,A list of quasi-prob distributions,A PrimitiveResult with one PubResult per PUB,A single PubResult for all PUBs,A SamplerResult V1 object,A PrimitiveResult with one PubResult per PUB,V2 returns a PrimitiveResult container that holds per‑PUB results.
Which reference implementations ship with Qiskit for the V2 primitives?,BackendSamplerV2 and BackendEstimatorV2 only,StatevectorSampler and StatevectorEstimator,DeviceSamplerV2 only,NoiseModelEstimator only,StatevectorSampler and StatevectorEstimator,These are the reference (statevector) implementations of the V2 abstractions.
"In the Sampler example, where are measurement outcomes stored for a register named 'alpha'?",result.data.alpha,result[0].metadata['alpha'],result[0].data.alpha,result.alpha.values,result[0].data.alpha,"Each PUB’s data bin exposes a field per classical register (e.g., data.alpha)."
Which API difference is explicitly highlighted between V1 and V2 regarding sampling overhead?,V1 has shots in run(); V2 moves shots to options,V2 adds shots to the run() API and per‑PUB; V1 hid this in options,Both V1 and V2 use only options for shots,V2 removes the concept of shots entirely,V2 adds shots to the run() API and per‑PUB; V1 hid this in options,Docs note V2 brings sampling overhead into the API; V1 handled via options.
What is the purpose of BackendEstimatorV2 / BackendSamplerV2 classes?,They are abstract base classes for V2 primitives,They are deprecated V1 classes kept for compatibility,They evaluate pubs on a backend device or backend interface,They are mock test doubles for unit testing only,They evaluate pubs on a backend device or backend interface,They are concrete backend‑driven implementations of the V2 abstractions.
Which statement about V1 implementations in current Qiskit is true?,Qiskit includes working EstimatorV1 and SamplerV1 implementations,There are no current implementations of EstimatorV1/SamplerV1 in Qiskit,Only EstimatorV1 exists today; SamplerV1 was removed,Only SamplerV1 exists today; EstimatorV1 was removed,There are no current implementations of EstimatorV1/SamplerV1 in Qiskit,The docs clarify there are no V1 implementations; only abstract bases remain.
"In EstimatorV2, which call shows using precision for all PUBs in a single run?","estimator.run(pubs, shots=1024)","estimator.run(pubs, precision=0.05)","estimator.run(pubs, counts=True)","estimator.run(pubs, variance=0.05)","estimator.run(pubs, precision=0.05)",The run() method accepts a precision argument to target error bars on evs.
